<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CC_S (sidekick.Sidekick_core.CC_S)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">sidekick</a> &#x00BB; <a href="../index.html">Sidekick_core</a> &#x00BB; CC_S</nav><header class="odoc-preamble"><h1>Module type <code><span>Sidekick_core.CC_S</span></code></h1><p>Main congruence closure signature.</p><p>The congruence closure handles the theory QF_UF (uninterpreted function symbols). It is also responsible for <i>theory combination</i>, and provides a general framework for equality reasoning that other theories piggyback on.</p><p>For example, the theory of datatypes relies on the congruence closure to do most of the work, and &quot;only&quot; adds injectivity/disjointness/acyclicity lemmas when needed.</p><p>Similarly, a theory of arrays would hook into the congruence closure and assert (dis)equalities as needed.</p><p>first, some aliases.</p></header><nav class="odoc-toc"><ul><li><a href="#accessors">Accessors</a></li><li><a href="#events">Events</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-T" class="anchored"><a href="#module-T" class="anchor"></a><code><span><span class="keyword">module</span> <a href="T/index.html">T</a></span><span> : <a href="../module-type-TERM/index.html">TERM</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Lit" class="anchored"><a href="#module-Lit" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Lit/index.html">Lit</a></span><span> : <a href="../module-type-LIT/index.html">LIT</a> <span class="keyword">with</span> <span><span class="keyword">module</span> <a href="../module-type-LIT/T/index.html">T</a> = <a href="T/index.html">T</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-proof" class="anchored"><a href="#type-proof" class="anchor"></a><code><span><span class="keyword">type</span> proof</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-proof_step" class="anchored"><a href="#type-proof_step" class="anchor"></a><code><span><span class="keyword">type</span> proof_step</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-P" class="anchored"><a href="#module-P" class="anchor"></a><code><span><span class="keyword">module</span> <a href="P/index.html">P</a></span><span> : 
  <a href="../module-type-PROOF/index.html">PROOF</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../module-type-PROOF/index.html#type-lit">lit</a> = <a href="Lit/index.html#type-t">Lit.t</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../module-type-PROOF/index.html#type-t">t</a> = <a href="#type-proof">proof</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../module-type-PROOF/index.html#type-proof_step">proof_step</a> = <a href="#type-proof_step">proof_step</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Actions" class="anchored"><a href="#module-Actions" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Actions/index.html">Actions</a></span><span> : 
  <a href="../module-type-CC_ACTIONS/index.html">CC_ACTIONS</a>
    <span class="keyword">with</span> <span><span class="keyword">module</span> <a href="../module-type-CC_ACTIONS/T/index.html">T</a> = <a href="T/index.html">T</a></span>
     <span class="keyword">and</span> <span><span class="keyword">module</span> <a href="../module-type-CC_ACTIONS/Lit/index.html">Lit</a> = <a href="Lit/index.html">Lit</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../module-type-CC_ACTIONS/index.html#type-proof">proof</a> = <a href="#type-proof">proof</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../module-type-CC_ACTIONS/index.html#type-proof_step">proof_step</a> = <a href="#type-proof_step">proof_step</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-term_store" class="anchored"><a href="#type-term_store" class="anchor"></a><code><span><span class="keyword">type</span> term_store</span><span> = <a href="T/Term/index.html#type-store">T.Term.store</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-term" class="anchored"><a href="#type-term" class="anchor"></a><code><span><span class="keyword">type</span> term</span><span> = <a href="T/Term/index.html#type-t">T.Term.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-value" class="anchored"><a href="#type-value" class="anchor"></a><code><span><span class="keyword">type</span> value</span><span> = <a href="#type-term">term</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-fun_" class="anchored"><a href="#type-fun_" class="anchor"></a><code><span><span class="keyword">type</span> fun_</span><span> = <a href="T/Fun/index.html#type-t">T.Fun.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-lit" class="anchored"><a href="#type-lit" class="anchor"></a><code><span><span class="keyword">type</span> lit</span><span> = <a href="Lit/index.html#type-t">Lit.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-actions" class="anchored"><a href="#type-actions" class="anchor"></a><code><span><span class="keyword">type</span> actions</span><span> = <a href="Actions/index.html#type-t">Actions.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The congruence closure object. It contains a fair amount of state and is mutable and backtrackable.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-N" class="anchored"><a href="#module-N" class="anchor"></a><code><span><span class="keyword">module</span> <a href="N/index.html">N</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Equivalence classes.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Expl" class="anchored"><a href="#module-Expl" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Expl/index.html">Expl</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Explanations</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Resolved_expl" class="anchored"><a href="#module-Resolved_expl" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Resolved_expl/index.html">Resolved_expl</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Resolved explanations.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-node" class="anchored"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">type</span> node</span><span> = <a href="N/index.html#type-t">N.t</a></span></code></div><div class="spec-doc"><p>A node of the congruence closure</p></div></div><div class="odoc-spec"><div class="spec type" id="type-repr" class="anchored"><a href="#type-repr" class="anchor"></a><code><span><span class="keyword">type</span> repr</span><span> = <a href="N/index.html#type-t">N.t</a></span></code></div><div class="spec-doc"><p>Node that is currently a representative</p></div></div><div class="odoc-spec"><div class="spec type" id="type-explanation" class="anchored"><a href="#type-explanation" class="anchor"></a><code><span><span class="keyword">type</span> explanation</span><span> = <a href="Expl/index.html#type-t">Expl.t</a></span></code></div></div><h4 id="accessors"><a href="#accessors" class="anchor"></a>Accessors</h4><div class="odoc-spec"><div class="spec value" id="val-term_store" class="anchored"><a href="#val-term_store" class="anchor"></a><code><span><span class="keyword">val</span> term_store : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-term_store">term_store</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-proof" class="anchored"><a href="#val-proof" class="anchor"></a><code><span><span class="keyword">val</span> proof : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-proof">proof</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-repr">repr</a></span></code></div><div class="spec-doc"><p>Current representative</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_term" class="anchored"><a href="#val-add_term" class="anchor"></a><code><span><span class="keyword">val</span> add_term : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-node">node</a></span></code></div><div class="spec-doc"><p>Add the term to the congruence closure, if not present already. Will be backtracked.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem_term" class="anchored"><a href="#val-mem_term" class="anchor"></a><code><span><span class="keyword">val</span> mem_term : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns <code>true</code> if the term is explicitly present in the congruence closure</p></div></div><h4 id="events"><a href="#events" class="anchor"></a>Events</h4><p>Events triggered by the congruence closure, to which other plugins can subscribe.</p><div class="odoc-spec"><div class="spec type" id="type-ev_on_pre_merge" class="anchored"><a href="#type-ev_on_pre_merge" class="anchor"></a><code><span><span class="keyword">type</span> ev_on_pre_merge</span><span> = <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-actions">actions</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Expl/index.html#type-t">Expl.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>ev_on_pre_merge cc acts n1 n2 expl</code> is called right before <code>n1</code> and <code>n2</code> are merged with explanation <code>expl</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-ev_on_post_merge" class="anchored"><a href="#type-ev_on_post_merge" class="anchor"></a><code><span><span class="keyword">type</span> ev_on_post_merge</span><span> = <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-actions">actions</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>ev_on_post_merge cc acts n1 n2</code> is called right after <code>n1</code> and <code>n2</code> were merged. <code>find cc n1</code> and <code>find cc n2</code> will return the same node.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-ev_on_new_term" class="anchored"><a href="#type-ev_on_new_term" class="anchor"></a><code><span><span class="keyword">type</span> ev_on_new_term</span><span> = <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>ev_on_new_term cc n t</code> is called whenever a new term <code>t</code> is added to the congruence closure. Its node is <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-ev_on_conflict" class="anchored"><a href="#type-ev_on_conflict" class="anchor"></a><code><span><span class="keyword">type</span> ev_on_conflict</span><span> = <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>th:bool <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-lit">lit</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>ev_on_conflict acts ~th c</code> is called when the congruence closure triggers a conflict by asserting the tautology <code>c</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">th</span> <p>true if the explanation for this conflict involves at least one &quot;theory&quot; explanation; i.e. some of the equations participating in the conflict are purely syntactic theories like injectivity of constructors.</p></li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-ev_on_propagate" class="anchored"><a href="#type-ev_on_propagate" class="anchor"></a><code><span><span class="keyword">type</span> ev_on_propagate</span><span> = <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lit">lit</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lit">lit</a> list</span> * <a href="#type-proof_step">proof_step</a> )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>ev_on_propagate cc lit reason</code> is called whenever <code>reason() =&gt; lit</code> is a propagated lemma. See <a href="../module-type-CC_ACTIONS/index.html#val-propagate"><code>CC_ACTIONS.propagate</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-ev_on_is_subterm" class="anchored"><a href="#type-ev_on_is_subterm" class="anchor"></a><code><span><span class="keyword">type</span> ev_on_is_subterm</span><span> = <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>ev_on_is_subterm n t</code> is called when <code>n</code> is a subterm of another node for the first time. <code>t</code> is the term corresponding to the node <code>n</code>. This can be useful for theory combination.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span>?stat:<a href="../../Sidekick_util/Stat/index.html#type-t">Sidekick_util.Stat.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?on_pre_merge:<span><a href="#type-ev_on_pre_merge">ev_on_pre_merge</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?on_post_merge:<span><a href="#type-ev_on_post_merge">ev_on_post_merge</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?on_new_term:<span><a href="#type-ev_on_new_term">ev_on_new_term</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?on_conflict:<span><a href="#type-ev_on_conflict">ev_on_conflict</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?on_propagate:<span><a href="#type-ev_on_propagate">ev_on_propagate</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?on_is_subterm:<span><a href="#type-ev_on_is_subterm">ev_on_is_subterm</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?size:<span>[ `Small <span>| `Big</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-term_store">term_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a new congruence closure.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">term_store</span> <p>used to be able to create new terms. All terms interacting with this congruence closure must belong in this term state as well.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-allocate_bitfield" class="anchored"><a href="#val-allocate_bitfield" class="anchor"></a><code><span><span class="keyword">val</span> allocate_bitfield : <span>descr:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="N/index.html#type-bitfield">N.bitfield</a></span></code></div><div class="spec-doc"><p>Allocate a new node field (see <a href="N/index.html#type-bitfield"><code>N.bitfield</code></a>).</p><p>This field descriptor is henceforth reserved for all nodes in this congruence closure, and can be set using <a href="#val-set_bitfield"><code>set_bitfield</code></a> for each node individually. This can be used to efficiently store some metadata on nodes (e.g. &quot;is there a numeric value in the class&quot; or &quot;is there a constructor term in the class&quot;).</p><p>There may be restrictions on how many distinct fields are allocated for a given congruence closure (e.g. at most <code>Sys</code>.int_size fields).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_bitfield" class="anchored"><a href="#val-get_bitfield" class="anchor"></a><code><span><span class="keyword">val</span> get_bitfield : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-bitfield">N.bitfield</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Access the bit field of the given node</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_bitfield" class="anchored"><a href="#val-set_bitfield" class="anchor"></a><code><span><span class="keyword">val</span> set_bitfield : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-bitfield">N.bitfield</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Set the bitfield for the node. This will be backtracked. See <a href="N/index.html#type-bitfield"><code>N.bitfield</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_pre_merge" class="anchored"><a href="#val-on_pre_merge" class="anchor"></a><code><span><span class="keyword">val</span> on_pre_merge : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ev_on_pre_merge">ev_on_pre_merge</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a function to be called when two classes are merged</p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_post_merge" class="anchored"><a href="#val-on_post_merge" class="anchor"></a><code><span><span class="keyword">val</span> on_post_merge : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ev_on_post_merge">ev_on_post_merge</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a function to be called when two classes are merged</p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_new_term" class="anchored"><a href="#val-on_new_term" class="anchor"></a><code><span><span class="keyword">val</span> on_new_term : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ev_on_new_term">ev_on_new_term</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a function to be called when a new node is created</p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_conflict" class="anchored"><a href="#val-on_conflict" class="anchor"></a><code><span><span class="keyword">val</span> on_conflict : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ev_on_conflict">ev_on_conflict</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Called when the congruence closure finds a conflict</p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_propagate" class="anchored"><a href="#val-on_propagate" class="anchor"></a><code><span><span class="keyword">val</span> on_propagate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ev_on_propagate">ev_on_propagate</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Called when the congruence closure propagates a literal</p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_is_subterm" class="anchored"><a href="#val-on_is_subterm" class="anchor"></a><code><span><span class="keyword">val</span> on_is_subterm : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ev_on_is_subterm">ev_on_is_subterm</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Called on terms that are subterms of function symbols</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_as_lit" class="anchored"><a href="#val-set_as_lit" class="anchor"></a><code><span><span class="keyword">val</span> set_as_lit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lit">lit</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>map the given node to a literal.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_t" class="anchored"><a href="#val-find_t" class="anchor"></a><code><span><span class="keyword">val</span> find_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-repr">repr</a></span></code></div><div class="spec-doc"><p>Current representative of the term.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the term is not already <code>add</code>-ed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-add_seq" class="anchored"><a href="#val-add_seq" class="anchor"></a><code><span><span class="keyword">val</span> add_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> <span class="xref-unresolved">Iter</span>.t</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a sequence of terms to the congruence closure</p></div></div><div class="odoc-spec"><div class="spec value" id="val-all_classes" class="anchored"><a href="#val-all_classes" class="anchor"></a><code><span><span class="keyword">val</span> all_classes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-repr">repr</a> <span class="xref-unresolved">Iter</span>.t</span></span></code></div><div class="spec-doc"><p>All current classes. This is costly, only use if there is no other solution</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assert_lit" class="anchored"><a href="#val-assert_lit" class="anchor"></a><code><span><span class="keyword">val</span> assert_lit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lit">lit</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Given a literal, assume it in the congruence closure and propagate its consequences. Will be backtracked.</p><p>Useful for the theory combination or the SAT solver's functor</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assert_lits" class="anchored"><a href="#val-assert_lits" class="anchor"></a><code><span><span class="keyword">val</span> assert_lits : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-lit">lit</a> <span class="xref-unresolved">Iter</span>.t</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Addition of many literals</p></div></div><div class="odoc-spec"><div class="spec value" id="val-explain_eq" class="anchored"><a href="#val-explain_eq" class="anchor"></a><code><span><span class="keyword">val</span> explain_eq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Resolved_expl/index.html#type-t">Resolved_expl.t</a></span></code></div><div class="spec-doc"><p>Explain why the two nodes are equal. Fails if they are not, in an unspecified way.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-raise_conflict_from_expl" class="anchored"><a href="#val-raise_conflict_from_expl" class="anchor"></a><code><span><span class="keyword">val</span> raise_conflict_from_expl : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-actions">actions</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Expl/index.html#type-t">Expl.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Raise a conflict with the given explanation. It must be a theory tautology that <code>expl ==&gt; absurd</code>. To be used in theories.</p><p>This fails in an unspecified way if the explanation, once resolved, satisfies <a href="Resolved_expl/index.html#val-is_semantic"><code>Resolved_expl.is_semantic</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-n_true" class="anchored"><a href="#val-n_true" class="anchor"></a><code><span><span class="keyword">val</span> n_true : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="N/index.html#type-t">N.t</a></span></code></div><div class="spec-doc"><p>Node for <code>true</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-n_false" class="anchored"><a href="#val-n_false" class="anchor"></a><code><span><span class="keyword">val</span> n_false : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="N/index.html#type-t">N.t</a></span></code></div><div class="spec-doc"><p>Node for <code>false</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-n_bool" class="anchored"><a href="#val-n_bool" class="anchor"></a><code><span><span class="keyword">val</span> n_bool : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="N/index.html#type-t">N.t</a></span></code></div><div class="spec-doc"><p>Node for either true or false</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="N/index.html#type-t">N.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Expl/index.html#type-t">Expl.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Merge these two nodes given this explanation. It must be a theory tautology that <code>expl ==&gt; n1 = n2</code>. To be used in theories.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge_t" class="anchored"><a href="#val-merge_t" class="anchor"></a><code><span><span class="keyword">val</span> merge_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Expl/index.html#type-t">Expl.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Shortcut for adding + merging</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_model_value" class="anchored"><a href="#val-set_model_value" class="anchor"></a><code><span><span class="keyword">val</span> set_model_value : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-value">value</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Set the value of a term in the model.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_model_mode" class="anchored"><a href="#val-with_model_mode" class="anchor"></a><code><span><span class="keyword">val</span> with_model_mode : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Enter model combination mode.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_model_for_each_class" class="anchored"><a href="#val-get_model_for_each_class" class="anchor"></a><code><span><span class="keyword">val</span> get_model_for_each_class : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-repr">repr</a> * <span><a href="N/index.html#type-t">N.t</a> <span class="xref-unresolved">Iter</span>.t</span> * <a href="#type-value">value</a>)</span> <span class="xref-unresolved">Iter</span>.t</span></span></code></div><div class="spec-doc"><p>In model combination mode, obtain classes with their values.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check" class="anchored"><a href="#val-check" class="anchor"></a><code><span><span class="keyword">val</span> check : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-actions">actions</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Perform all pending operations done via <code>assert_eq</code>, <a href="#val-assert_lit"><code>assert_lit</code></a>, etc. Will use the <a href="#type-actions"><code>actions</code></a> to propagate literals, declare conflicts, etc.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-push_level" class="anchored"><a href="#val-push_level" class="anchor"></a><code><span><span class="keyword">val</span> push_level : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Push backtracking level</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_levels" class="anchored"><a href="#val-pop_levels" class="anchor"></a><code><span><span class="keyword">val</span> pop_levels : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Restore to state <code>n</code> calls to <code>push_level</code> earlier. Used during backtracking.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_model" class="anchored"><a href="#val-get_model" class="anchor"></a><code><span><span class="keyword">val</span> get_model : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="N/index.html#type-t">N.t</a> <span class="xref-unresolved">Iter</span>.t</span> <span class="xref-unresolved">Iter</span>.t</span></span></code></div><div class="spec-doc"><p>get all the equivalence classes so they can be merged in the model</p></div></div></div></body></html>