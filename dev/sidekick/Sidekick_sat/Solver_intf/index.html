<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Solver_intf (sidekick.Sidekick_sat.Solver_intf)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">sidekick</a> &#x00BB; <a href="../index.html">Sidekick_sat</a> &#x00BB; Solver_intf</nav><header class="odoc-preamble"><h1>Module <code><span>Sidekick_sat.Solver_intf</span></code></h1><p>Interface for Solvers</p><p>This modules defines the safe external interface for solvers. Solvers that implements this interface can be obtained using the <code>Make</code> functor in <a href="../Solver/index.html"><code>Solver</code></a> or <code>Mcsolver</code>.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-printer" class="anchored"><a href="#type-printer" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a printer</span></span><span> = <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-SAT_STATE" class="anchored"><a href="#module-type-SAT_STATE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-SAT_STATE/index.html">SAT_STATE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-sat_state" class="anchored"><a href="#type-sat_state" class="anchor"></a><code><span><span class="keyword">type</span> <span>'form sat_state</span></span><span> = <span>(<span class="keyword">module</span> <a href="module-type-SAT_STATE/index.html">SAT_STATE</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-SAT_STATE/index.html#type-lit">lit</a> = <span class="type-var">'form</span>)</span></span></code></div><div class="spec-doc"><p>The type of values returned when the solver reaches a SAT state.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-UNSAT_STATE" class="anchored"><a href="#module-type-UNSAT_STATE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-UNSAT_STATE/index.html">UNSAT_STATE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-unsat_state" class="anchored"><a href="#type-unsat_state" class="anchor"></a><code><span><span class="keyword">type</span> <span>('lit, 'clause, 'proof) unsat_state</span></span><span> = <span>(<span class="keyword">module</span> <a href="module-type-UNSAT_STATE/index.html">UNSAT_STATE</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-UNSAT_STATE/index.html#type-clause">clause</a> = <span class="type-var">'clause</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-UNSAT_STATE/index.html#type-lit">lit</a> = <span class="type-var">'lit</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-UNSAT_STATE/index.html#type-proof">proof</a> = <span class="type-var">'proof</span>)</span></span></code></div><div class="spec-doc"><p>The type of values returned when the solver reaches an UNSAT state.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-same_sign" class="anchored"><a href="#type-same_sign" class="anchor"></a><code><span><span class="keyword">type</span> same_sign</span><span> = bool</span></code></div><div class="spec-doc"><p>This type is used during the normalisation of lits. <code>true</code> means the literal stayed the same, <code>false</code> that its sign was flipped.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-reason" class="anchored"><a href="#type-reason" class="anchor"></a><code><span><span class="keyword">type</span> <span>('lit, 'proof) reason</span></span><span> = </span></code><table><tr id="type-reason.Consequence" class="anchored"><td class="def variant constructor"><a href="#type-reason.Consequence" class="anchor"></a><code><span>| </span><span><span class="constructor">Consequence</span> <span class="keyword">of</span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'lit</span> list</span> * <span class="type-var">'proof</span></span></code></td></tr></table></div><div class="spec-doc"><p>The type of reasons for propagations of a lit <code>f</code>.</p><p><code>Consequence (l, p)</code> means that the lits in <code>l</code> imply the propagated lit <code>f</code>. The proof should be a proof of the clause &quot;<code>l</code> implies <code>f</code>&quot;.</p><p>invariant: in <code>Consequence (fun () -&gt; l,p)</code>, all elements of <code>l</code> must be true in the current trail.</p><p><b>note</b> on lazyiness: the justification is suspended (using <code>unit -&gt; …</code>) to avoid potentially costly computations that might never be used if this literal is backtracked without participating in a conflict. Therefore the function that produces <code>(l,p)</code> needs only be safe in trails (partial models) that are conservative extensions of the current trail. If the theory isn't robust w.r.t. extensions of the trail (e.g. if its internal state undergoes significant changes), it can be easier to produce the explanation eagerly when propagating, and then use <code>Consequence (fun () -&gt; expl, proof)</code> with the already produced <code>(expl,proof)</code> tuple.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-lbool" class="anchored"><a href="#type-lbool" class="anchor"></a><code><span><span class="keyword">type</span> lbool</span><span> = </span></code><table><tr id="type-lbool.L_true" class="anchored"><td class="def variant constructor"><a href="#type-lbool.L_true" class="anchor"></a><code><span>| </span><span><span class="constructor">L_true</span></span></code></td></tr><tr id="type-lbool.L_false" class="anchored"><td class="def variant constructor"><a href="#type-lbool.L_false" class="anchor"></a><code><span>| </span><span><span class="constructor">L_false</span></span></code></td></tr><tr id="type-lbool.L_undefined" class="anchored"><td class="def variant constructor"><a href="#type-lbool.L_undefined" class="anchor"></a><code><span>| </span><span><span class="constructor">L_undefined</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Valuation of an atom</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec module" id="module-Clause_pool_id" class="anchored"><a href="#module-Clause_pool_id" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Clause_pool_id/index.html">Clause_pool_id</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-ACTS" class="anchored"><a href="#module-type-ACTS" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-ACTS/index.html">ACTS</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Actions available to the Plugin</p></div></div><div class="odoc-spec"><div class="spec type" id="type-acts" class="anchored"><a href="#type-acts" class="anchor"></a><code><span><span class="keyword">type</span> <span>('lit, 'proof, 'proof_step) acts</span></span><span> = <span>(<span class="keyword">module</span> <a href="module-type-ACTS/index.html">ACTS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-ACTS/index.html#type-lit">lit</a> = <span class="type-var">'lit</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-ACTS/index.html#type-proof">proof</a> = <span class="type-var">'proof</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-ACTS/index.html#type-proof_step">proof_step</a> = <span class="type-var">'proof_step</span>)</span></span></code></div><div class="spec-doc"><p>The type for a slice of assertions to assume/propagate in the theory.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-No_proof" class="anchored"><a href="#exception-No_proof" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">No_proof</span></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-LIT" class="anchored"><a href="#module-type-LIT" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-LIT/index.html">LIT</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>lits</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-PROOF" class="anchored"><a href="#module-type-PROOF" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span>PROOF</span><span> = <a href="../../Sidekick_core/module-type-SAT_PROOF/index.html">Sidekick_core.SAT_PROOF</a></span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-PLUGIN_CDCL_T" class="anchored"><a href="#module-type-PLUGIN_CDCL_T" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-PLUGIN_CDCL_T/index.html">PLUGIN_CDCL_T</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Signature for theories to be given to the CDCL(T) solver</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-PLUGIN_SAT" class="anchored"><a href="#module-type-PLUGIN_SAT" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-PLUGIN_SAT/index.html">PLUGIN_SAT</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Signature for pure SAT solvers</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-S" class="anchored"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> </span><span><a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The external interface implemented by safe solvers, such as the one created by the <code>Solver</code>.Make and <code>Mcsolver</code>.Make functors.</p></div></div></div></body></html>