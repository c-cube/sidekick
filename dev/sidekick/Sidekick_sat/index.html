<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sidekick_sat (sidekick.Sidekick_sat)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">sidekick</a> &#x00BB; Sidekick_sat</nav><header class="odoc-preamble"><h1>Module <code><span>Sidekick_sat</span></code></h1><p>Main API</p></header><div class="odoc-content"><div class="odoc-include"><div class="odoc-spec"><div class="spec module-type" id="module-type-SAT_STATE" class="anchored"><a href="#module-type-SAT_STATE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SAT_STATE/index.html">SAT_STATE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Solver in a &quot;SATISFIABLE&quot; state</p></div></div><div class="odoc-spec"><div class="spec type" id="type-sat_state" class="anchored"><a href="#type-sat_state" class="anchor"></a><code><span><span class="keyword">type</span> sat_state</span><span> = <span>(<span class="keyword">module</span> <a href="module-type-SAT_STATE/index.html">SAT_STATE</a>)</span></span></code></div><div class="spec-doc"><p>The type of values returned when the solver reaches a SAT state.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-UNSAT_STATE" class="anchored"><a href="#module-type-UNSAT_STATE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-UNSAT_STATE/index.html">UNSAT_STATE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Solver in an &quot;UNSATISFIABLE&quot; state</p></div></div><div class="odoc-spec"><div class="spec type" id="type-unsat_state" class="anchored"><a href="#type-unsat_state" class="anchor"></a><code><span><span class="keyword">type</span> <span>'clause unsat_state</span></span><span> = <span>(<span class="keyword">module</span> <a href="module-type-UNSAT_STATE/index.html">UNSAT_STATE</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-UNSAT_STATE/index.html#type-clause">clause</a> = <span class="type-var">'clause</span>)</span></span></code></div><div class="spec-doc"><p>The type of values returned when the solver reaches an UNSAT state.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-same_sign" class="anchored"><a href="#type-same_sign" class="anchor"></a><code><span><span class="keyword">type</span> same_sign</span><span> = bool</span></code></div><div class="spec-doc"><p>This type is used during the normalisation of lits. <code>true</code> means the literal stayed the same, <code>false</code> that its sign was flipped.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-reason" class="anchored"><a href="#type-reason" class="anchor"></a><code><span><span class="keyword">type</span> reason</span><span> = </span></code><table><tr id="type-reason.Consequence" class="anchored"><td class="def variant constructor"><a href="#type-reason.Consequence" class="anchor"></a><code><span>| </span><span><span class="constructor">Consequence</span> <span class="keyword">of</span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> list</span> * <a href="../Sidekick_core/Proof_step/index.html#type-id">Sidekick_core.Proof_step.id</a></span></code></td></tr></table></div><div class="spec-doc"><p>The type of reasons for propagations of a lit <code>f</code>.</p><p><code>Consequence (l, p)</code> means that the lits in <code>l</code> imply the propagated lit <code>f</code>. The proof should be a proof of the clause &quot;<code>l</code> implies <code>f</code>&quot;.</p><p>invariant: in <code>Consequence (fun () -&gt; l,p)</code>, all elements of <code>l</code> must be true in the current trail.</p><p><b>note</b> on lazyiness: the justification is suspended (using <code>unit -&gt; …</code>) to avoid potentially costly computations that might never be used if this literal is backtracked without participating in a conflict. Therefore the function that produces <code>(l,p)</code> needs only be safe in trails (partial models) that are conservative extensions of the current trail. If the theory isn't robust w.r.t. extensions of the trail (e.g. if its internal state undergoes significant changes), it can be easier to produce the explanation eagerly when propagating, and then use <code>Consequence (fun () -&gt; expl, proof)</code> with the already produced <code>(expl,proof)</code> tuple.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-lbool" class="anchored"><a href="#type-lbool" class="anchor"></a><code><span><span class="keyword">type</span> lbool</span><span> = </span></code><table><tr id="type-lbool.L_true" class="anchored"><td class="def variant constructor"><a href="#type-lbool.L_true" class="anchor"></a><code><span>| </span><span><span class="constructor">L_true</span></span></code></td></tr><tr id="type-lbool.L_false" class="anchored"><td class="def variant constructor"><a href="#type-lbool.L_false" class="anchor"></a><code><span>| </span><span><span class="constructor">L_false</span></span></code></td></tr><tr id="type-lbool.L_undefined" class="anchored"><td class="def variant constructor"><a href="#type-lbool.L_undefined" class="anchor"></a><code><span>| </span><span><span class="constructor">L_undefined</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Valuation of an atom</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_lbool" class="anchored"><a href="#val-pp_lbool" class="anchor"></a><code><span><span class="keyword">val</span> pp_lbool : <span><span class="xref-unresolved">Sidekick_core</span>.Fmt.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lbool">lbool</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-ACTS" class="anchored"><a href="#module-type-ACTS" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ACTS/index.html">ACTS</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Actions available to the Plugin.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-acts" class="anchored"><a href="#type-acts" class="anchor"></a><code><span><span class="keyword">type</span> acts</span><span> = <span>(<span class="keyword">module</span> <a href="module-type-ACTS/index.html">ACTS</a>)</span></span></code></div><div class="spec-doc"><p>The type for a slice of assertions to assume/propagate in the theory.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-THEORY_CDCL_T" class="anchored"><a href="#module-type-THEORY_CDCL_T" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-THEORY_CDCL_T/index.html">THEORY_CDCL_T</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Signature for theories to be given to the CDCL(T) solver</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-PLUGIN" class="anchored"><a href="#module-type-PLUGIN" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PLUGIN/index.html">PLUGIN</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div><div class="odoc-spec"><div class="spec module" id="module-Solver" class="anchored"><a href="#module-Solver" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Solver/index.html">Solver</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The external interface implemented by SAT solvers.</p></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="Solver/index.html">Solver</a> <span class="keyword">end</span></span></code></summary><div class="odoc-spec"><div class="spec type" id="type-clause" class="anchored"><a href="#type-clause" class="anchor"></a><code><span><span class="keyword">type</span> clause</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-plugin" class="anchored"><a href="#type-plugin" class="anchor"></a><code><span><span class="keyword">type</span> plugin</span><span> = <span>(<span class="keyword">module</span> <span class="xref-unresolved">Sidekick_sat__Sigs.PLUGIN</span>)</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-solver" class="anchored"><a href="#type-solver" class="anchor"></a><code><span><span class="keyword">type</span> solver</span></code></div><div class="spec-doc"><p>The main solver type.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-store" class="anchored"><a href="#type-store" class="anchor"></a><code><span><span class="keyword">type</span> store</span></code></div><div class="spec-doc"><p>Stores atoms, clauses, etc.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Clause" class="anchored"><a href="#module-Clause" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Clause/index.html">Clause</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="main-solver-type_2"><a href="#main-solver-type_2" class="anchor"></a>Main Solver Type</h3><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="#type-solver">solver</a></span></code></div><div class="spec-doc"><p>Main solver type, containing all state for solving.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-store" class="anchored"><a href="#val-store" class="anchor"></a><code><span><span class="keyword">val</span> store : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-store">store</a></span></code></div><div class="spec-doc"><p>Store for the solver</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stat" class="anchored"><a href="#val-stat" class="anchor"></a><code><span><span class="keyword">val</span> stat : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Sidekick_util/Stat/index.html#type-t">Sidekick_util.Stat.t</a></span></code></div><div class="spec-doc"><p>Statistics</p></div></div><div class="odoc-spec"><div class="spec value" id="val-proof" class="anchored"><a href="#val-proof" class="anchor"></a><code><span><span class="keyword">val</span> proof : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Sidekick_core/Proof_trace/index.html#type-t">Sidekick_core.Proof_trace.t</a></span></code></div><div class="spec-doc"><p>Access the inner proof</p></div></div><div class="odoc-spec"><div class="spec value" id="val-on_conflict" class="anchored"><a href="#val-on_conflict" class="anchor"></a><code><span><span class="keyword">val</span> on_conflict : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="Clause/index.html#type-t">Clause.t</a>, unit )</span> <a href="../Sidekick_util/Event/index.html#type-t">Sidekick_util.Event.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-on_decision" class="anchored"><a href="#val-on_decision" class="anchor"></a><code><span><span class="keyword">val</span> on_decision : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a>, unit )</span> <a href="../Sidekick_util/Event/index.html#type-t">Sidekick_util.Event.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-on_learnt" class="anchored"><a href="#val-on_learnt" class="anchor"></a><code><span><span class="keyword">val</span> on_learnt : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <a href="Clause/index.html#type-t">Clause.t</a>, unit )</span> <a href="../Sidekick_util/Event/index.html#type-t">Sidekick_util.Event.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-on_gc" class="anchored"><a href="#val-on_gc" class="anchor"></a><code><span><span class="keyword">val</span> on_gc : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> array</span>, unit )</span> <a href="../Sidekick_util/Event/index.html#type-t">Sidekick_util.Event.t</a></span></span></code></div></div><h3 id="types_2"><a href="#types_2" class="anchor"></a>Types</h3><div class="odoc-spec"><div class="spec type" id="type-res" class="anchored"><a href="#type-res" class="anchor"></a><code><span><span class="keyword">type</span> res</span><span> = </span></code><table><tr id="type-res.Sat" class="anchored"><td class="def variant constructor"><a href="#type-res.Sat" class="anchor"></a><code><span>| </span><span><span class="constructor">Sat</span> <span class="keyword">of</span> <span>(<span class="keyword">module</span> <span class="xref-unresolved">Sidekick_sat__Sigs.SAT_STATE</span>)</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Returned when the solver reaches SAT, with a model</p><span class="comment-delim">*)</span></td></tr><tr id="type-res.Unsat" class="anchored"><td class="def variant constructor"><a href="#type-res.Unsat" class="anchor"></a><code><span>| </span><span><span class="constructor">Unsat</span> <span class="keyword">of</span> <span>(<span class="keyword">module</span> <span class="xref-unresolved">Sidekick_sat__Sigs.UNSAT_STATE</span> <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">clause</span> = <a href="#type-clause">clause</a>)</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Returned when the solver reaches UNSAT, with a proof</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Result type for the solver</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-UndecidedLit" class="anchored"><a href="#exception-UndecidedLit" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">UndecidedLit</span></span></code></div><div class="spec-doc"><p>Exception raised by the evaluating functions when a literal has not yet been assigned a value.</p></div></div><h3 id="base-operations_2"><a href="#base-operations_2" class="anchor"></a>Base operations</h3><div class="odoc-spec"><div class="spec value" id="val-assume" class="anchored"><a href="#val-assume" class="anchor"></a><code><span><span class="keyword">val</span> assume : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add the list of clauses to the current set of assumptions. Modifies the sat solver state in place.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_clause" class="anchored"><a href="#val-add_clause" class="anchor"></a><code><span><span class="keyword">val</span> add_clause : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sidekick_core/Proof_step/index.html#type-id">Sidekick_core.Proof_step.id</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Lower level addition of clauses</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_clause_a" class="anchored"><a href="#val-add_clause_a" class="anchor"></a><code><span><span class="keyword">val</span> add_clause_a : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sidekick_core/Proof_step/index.html#type-id">Sidekick_core.Proof_step.id</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Lower level addition of clauses</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_input_clause" class="anchored"><a href="#val-add_input_clause" class="anchor"></a><code><span><span class="keyword">val</span> add_input_clause : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Like <a href="#val-add_clause"><code>add_clause</code></a> but with the justification of being an input clause</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_input_clause_a" class="anchored"><a href="#val-add_input_clause_a" class="anchor"></a><code><span><span class="keyword">val</span> add_input_clause_a : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Like <a href="#val-add_clause_a"><code>add_clause_a</code></a> but with justification of being an input clause</p></div></div><h3 id="solving_2"><a href="#solving_2" class="anchor"></a>Solving</h3><div class="odoc-spec"><div class="spec value" id="val-solve" class="anchored"><a href="#val-solve" class="anchor"></a><code><span><span class="keyword">val</span> solve : 
  <span>?on_progress:<span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?assumptions:<span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-res">res</a></span></code></div><div class="spec-doc"><p>Try and solves the current set of clauses.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">assumptions</span> <p>additional atomic assumptions to be temporarily added. The assumptions are just used for this call to <code>solve</code>, they are not saved in the solver's state.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">on_progress</span> <p>regularly called during solving. Can raise <code>Resource_exhausted</code> to stop solving.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Resource_exhausted</span> <p>if the on_progress handler raised it to stop</p></li></ul></div></div><h3 id="evaluating-and-adding-literals_2"><a href="#evaluating-and-adding-literals_2" class="anchor"></a>Evaluating and adding literals</h3><div class="odoc-spec"><div class="spec value" id="val-add_lit" class="anchored"><a href="#val-add_lit" class="anchor"></a><code><span><span class="keyword">val</span> add_lit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?default_pol:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Ensure the SAT solver handles this particular literal, ie add a boolean variable for it if it's not already there.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_default_pol" class="anchored"><a href="#val-set_default_pol" class="anchor"></a><code><span><span class="keyword">val</span> set_default_pol : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Set default polarity for the given boolean variable. Sign of the literal is ignored.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-true_at_level0" class="anchored"><a href="#val-true_at_level0" class="anchor"></a><code><span><span class="keyword">val</span> true_at_level0 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>true_at_level0 a</code> returns <code>true</code> if <code>a</code> was proved at level0, i.e. it must hold in all models</p></div></div><div class="odoc-spec"><div class="spec value" id="val-eval_lit" class="anchored"><a href="#val-eval_lit" class="anchor"></a><code><span><span class="keyword">val</span> eval_lit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Sidekick_sat__Sigs.lbool</span></span></code></div><div class="spec-doc"><p>Evaluate atom in current state</p></div></div><h3 id="assumption-stack_2"><a href="#assumption-stack_2" class="anchor"></a>Assumption stack</h3><div class="odoc-spec"><div class="spec value" id="val-push_assumption" class="anchored"><a href="#val-push_assumption" class="anchor"></a><code><span><span class="keyword">val</span> push_assumption : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pushes an assumption onto the assumption stack. It will remain there until it's pop'd by <a href="#val-pop_assumptions"><code>pop_assumptions</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_assumptions" class="anchored"><a href="#val-pop_assumptions" class="anchor"></a><code><span><span class="keyword">val</span> pop_assumptions : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pop_assumptions solver n</code> removes <code>n</code> assumptions from the stack. It removes the assumptions that were the most recently added via <code>push_assumptions</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-propagation_result" class="anchored"><a href="#type-propagation_result" class="anchor"></a><code><span><span class="keyword">type</span> propagation_result</span><span> = </span></code><table><tr id="type-propagation_result.PR_sat" class="anchored"><td class="def variant constructor"><a href="#type-propagation_result.PR_sat" class="anchor"></a><code><span>| </span><span><span class="constructor">PR_sat</span></span></code></td></tr><tr id="type-propagation_result.PR_conflict" class="anchored"><td class="def variant constructor"><a href="#type-propagation_result.PR_conflict" class="anchor"></a><code><span>| </span><span><span class="constructor">PR_conflict</span> <span class="keyword">of</span> </span><span>{</span></code><table><tr id="type-propagation_result.backtracked" class="anchored"><td class="def record field"><a href="#type-propagation_result.backtracked" class="anchor"></a><code><span>backtracked : int;</span></code></td></tr></table><code><span>}</span></code></td></tr><tr id="type-propagation_result.PR_unsat" class="anchored"><td class="def variant constructor"><a href="#type-propagation_result.PR_unsat" class="anchor"></a><code><span>| </span><span><span class="constructor">PR_unsat</span> <span class="keyword">of</span> <span>(<span class="keyword">module</span> <span class="xref-unresolved">Sidekick_sat__Sigs.UNSAT_STATE</span> <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">clause</span> = <a href="#type-clause">clause</a>)</span></span></code></td></tr></table></div><div class="spec-doc"><p>Result returned by <a href="#val-check_sat_propagations_only"><code>check_sat_propagations_only</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_sat_propagations_only" class="anchored"><a href="#val-check_sat_propagations_only" class="anchor"></a><code><span><span class="keyword">val</span> check_sat_propagations_only : 
  <span>?assumptions:<span><a href="../Sidekick_core/Lit/index.html#type-t">Sidekick_core.Lit.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-propagation_result">propagation_result</a></span></code></div><div class="spec-doc"><p><code>check_sat_propagations_only solver</code> uses the added clauses and local assumptions (using <code>push_assumptions</code> and <code>assumptions</code>) to quickly assess whether the context is satisfiable. It is not complete; calling <a href="#val-solve"><code>solve</code></a> is required to get an accurate result.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>either <code>Ok()</code> if propagation yielded no conflict, or <code>Error c</code> if a conflict clause <code>c</code> was found.</p></li></ul></div></div><h3 id="initialization_2"><a href="#initialization_2" class="anchor"></a>Initialization</h3><div class="odoc-spec"><div class="spec value" id="val-plugin_cdcl_t" class="anchored"><a href="#val-plugin_cdcl_t" class="anchor"></a><code><span><span class="keyword">val</span> plugin_cdcl_t : 
  <span><span>(<span class="keyword">module</span> <span class="xref-unresolved">Sidekick_sat__Sigs.THEORY_CDCL_T</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>(<span class="keyword">module</span> <span class="xref-unresolved">Sidekick_sat__Sigs.PLUGIN</span>)</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_plugin_cdcl_t" class="anchored"><a href="#val-mk_plugin_cdcl_t" class="anchor"></a><code><span><span class="keyword">val</span> mk_plugin_cdcl_t : 
  <span>push_level:<span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>pop_levels:<span>( <span>int <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?partial_check:<span>( <span><span>(<span class="keyword">module</span> <span class="xref-unresolved">Sidekick_sat__Sigs.ACTS</span>)</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>final_check:<span>( <span><span>(<span class="keyword">module</span> <span class="xref-unresolved">Sidekick_sat__Sigs.ACTS</span>)</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span>(<span class="keyword">module</span> <span class="xref-unresolved">Sidekick_sat__Sigs.PLUGIN</span>)</span></span></code></div><div class="spec-doc"><p>Create a plugin</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">push_level</span> <p>create a new backtrack level</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">pop_levels</span> <p>Pop <code>n</code> levels of the plugin</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">partial_check</span> <p>Assume the lits in the slice, possibly using the <code>slice</code> to push new lits to be propagated or to raising a conflict or to add new lemmas.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">final_check</span> <p>Called at the end of the search in case a model has been found. If no new clause is pushed, then proof search ends and &quot;sat&quot; is returned; if lemmas are added, search is resumed; if a conflict clause is added, search backtracks and then resumes.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span>?stat:<a href="../Sidekick_util/Stat/index.html#type-t">Sidekick_util.Stat.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?size:<span>[ `Tiny <span>| `Small</span> <span>| `Big</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>proof:<a href="../Sidekick_core/Proof_trace/index.html#type-t">Sidekick_core.Proof_trace.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-plugin">plugin</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create new solver</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">theory</span> <p>the theory</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">the</span> <p>proof</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">size</span> <p>the initial size of internal data structures. The bigger, the faster, but also the more RAM it uses.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-plugin_pure_sat" class="anchored"><a href="#val-plugin_pure_sat" class="anchor"></a><code><span><span class="keyword">val</span> plugin_pure_sat : <a href="#type-plugin">plugin</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create_pure_sat" class="anchored"><a href="#val-create_pure_sat" class="anchor"></a><code><span><span class="keyword">val</span> create_pure_sat : 
  <span>?stat:<a href="../Sidekick_util/Stat/index.html#type-t">Sidekick_util.Stat.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?size:<span>[ `Tiny <span>| `Small</span> <span>| `Big</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>proof:<a href="../Sidekick_core/Proof_trace/index.html#type-t">Sidekick_core.Proof_trace.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div></div></details></div></div></body></html>