<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Solver_internal (sidekick.Sidekick_smt_solver.Solver_internal)</title><link rel="stylesheet" href="../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">sidekick</a> &#x00BB; <a href="../index.html">Sidekick_smt_solver</a> &#x00BB; Solver_internal</nav><header class="odoc-preamble"><h1>Module <code><span>Sidekick_smt_solver.Solver_internal</span></code></h1><p>A view of the solver from a theory's point of view.</p><p>Theories should interact with the solver via this module, to assert new lemmas, propagate literals, access the congruence closure, etc.</p></header><nav class="odoc-toc"><ul><li><a href="#actions-for-the-theories">Actions for the theories</a></li><li><a href="#congruence-closure">Congruence Closure</a></li><li><a href="#backtracking">Backtracking</a></li><li><a href="#interface-to-sat">Interface to SAT</a></li><li><a href="#simplifiers">Simplifiers</a></li><li><a href="#preprocessors">Preprocessors</a></li><li><a href="#finding-foreign-variables">Finding foreign variables</a></li><li><a href="#hooks-for-the-theory">hooks for the theory</a></li><li><a href="#model-production">Model production</a></li><li><a href="#delayed-actions">Delayed actions</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Main type for the SMT solver</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-solver"><a href="#type-solver" class="anchor"></a><code><span><span class="keyword">type</span> solver</span><span> = <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tst"><a href="#val-tst" class="anchor"></a><code><span><span class="keyword">val</span> tst : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Sigs/index.html#type-term_store">Sigs.term_store</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stats"><a href="#val-stats" class="anchor"></a><code><span><span class="keyword">val</span> stats : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Sidekick_util/Stat/index.html#type-t">Sidekick_util.Stat.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tracer"><a href="#val-tracer" class="anchor"></a><code><span><span class="keyword">val</span> tracer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Tracer/class-type-t/index.html">Tracer.t</a></span></code></div><div class="spec-doc"><p>Access the tracer object</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-registry"><a href="#val-registry" class="anchor"></a><code><span><span class="keyword">val</span> registry : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Registry/index.html#type-t">Registry.t</a></span></code></div><div class="spec-doc"><p>A solver contains a registry so that theories can share data</p></div></div><h4 id="actions-for-the-theories"><a href="#actions-for-the-theories" class="anchor"></a>Actions for the theories</h4><div class="odoc-spec"><div class="spec type anchored" id="type-theory_actions"><a href="#type-theory_actions" class="anchor"></a><code><span><span class="keyword">type</span> theory_actions</span></code></div><div class="spec-doc"><p>Handle that the theories can use to perform actions.</p></div></div><h4 id="congruence-closure"><a href="#congruence-closure" class="anchor"></a>Congruence Closure</h4><div class="odoc-spec"><div class="spec value anchored" id="val-cc"><a href="#val-cc" class="anchor"></a><code><span><span class="keyword">val</span> cc : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Sidekick_cc/CC/index.html#type-t">Sidekick_cc.CC.t</a></span></code></div><div class="spec-doc"><p>Congruence closure for this solver</p></div></div><h4 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h4><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../Sidekick_sigs/module-type-BACKTRACKABLE0/index.html">Sidekick_sigs.BACKTRACKABLE0</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../Sidekick_sigs/module-type-BACKTRACKABLE0/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value anchored" id="val-n_levels"><a href="#val-n_levels" class="anchor"></a><code><span><span class="keyword">val</span> n_levels : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Number of levels</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-push_level"><a href="#val-push_level" class="anchor"></a><code><span><span class="keyword">val</span> push_level : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Push a backtracking point</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_levels"><a href="#val-pop_levels" class="anchor"></a><code><span><span class="keyword">val</span> pop_levels : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pop_levels st n</code> removes <code>n</code> levels</p></div></div></details></div><h4 id="interface-to-sat"><a href="#interface-to-sat" class="anchor"></a>Interface to SAT</h4><div class="odoc-spec"><div class="spec value anchored" id="val-to_sat_plugin"><a href="#val-to_sat_plugin" class="anchor"></a><code><span><span class="keyword">val</span> to_sat_plugin : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>(<span class="keyword">module</span> <a href="../../Sidekick_sat/module-type-PLUGIN/index.html">Sidekick_sat.PLUGIN</a>)</span></span></code></div></div><h4 id="simplifiers"><a href="#simplifiers" class="anchor"></a>Simplifiers</h4><div class="odoc-spec"><div class="spec type anchored" id="type-simplify_hook"><a href="#type-simplify_hook" class="anchor"></a><code><span><span class="keyword">type</span> simplify_hook</span><span> = <a href="../../Sidekick_simplify/index.html#type-hook">Sidekick_simplify.hook</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-simplifier"><a href="#val-simplifier" class="anchor"></a><code><span><span class="keyword">val</span> simplifier : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Sidekick_simplify/index.html#type-t">Sidekick_simplify.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_simplifier"><a href="#val-add_simplifier" class="anchor"></a><code><span><span class="keyword">val</span> add_simplifier : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Sidekick_simplify/index.html#type-hook">Sidekick_simplify.hook</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a simplifier hook for preprocessing.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-simplify_t"><a href="#val-simplify_t" class="anchor"></a><code><span><span class="keyword">val</span> simplify_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../Sigs/index.html#type-term">Sigs.term</a> * <a href="../Sigs/index.html#type-step_id">Sigs.step_id</a>)</span> option</span></span></code></div><div class="spec-doc"><p>Simplify input term, returns <code>Some u</code> if some simplification occurred.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-simp_t"><a href="#val-simp_t" class="anchor"></a><code><span><span class="keyword">val</span> simp_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Sigs/index.html#type-term">Sigs.term</a> * <span><a href="../Sigs/index.html#type-step_id">Sigs.step_id</a> option</span></span></code></div><div class="spec-doc"><p><code>simp_t si t</code> returns <code>u</code> even if no simplification occurred (in which case <code>t == u</code> syntactically). It emits <code>|- t=u</code>. (see <a href="#val-simplifier"><code>simplifier</code></a>)</p></div></div><h4 id="preprocessors"><a href="#preprocessors" class="anchor"></a>Preprocessors</h4><p>These preprocessors turn mixed, raw literals (possibly simplified) into literals suitable for reasoning. Typically some clauses are also added to the solver.</p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-PREPROCESS_ACTS"><a href="#module-type-PREPROCESS_ACTS" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> PREPROCESS_ACTS</span><span> = <a href="../Preprocess/module-type-PREPROCESS_ACTS/index.html">Preprocess.PREPROCESS_ACTS</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-preprocess_actions"><a href="#type-preprocess_actions" class="anchor"></a><code><span><span class="keyword">type</span> preprocess_actions</span><span> = <span>(<span class="keyword">module</span> <a href="../Preprocess/module-type-PREPROCESS_ACTS/index.html">PREPROCESS_ACTS</a>)</span></span></code></div><div class="spec-doc"><p>Actions available to the preprocessor</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-preprocess_hook"><a href="#type-preprocess_hook" class="anchor"></a><code><span><span class="keyword">type</span> preprocess_hook</span><span> =
  <span><a href="../Preprocess/index.html#type-t">Preprocess.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>is_sub:bool <span class="arrow">&#45;&gt;</span></span>
  <span>recurse:<span>(<span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Sigs/index.html#type-term">Sigs.term</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-preprocess_actions">preprocess_actions</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sigs/index.html#type-term">Sigs.term</a> option</span></span></code></div><div class="spec-doc"><p>Given a term, preprocess it.</p><p>The idea is to add literals and clauses to help define the meaning of the term, if needed. For example for boolean formulas, clauses for their Tseitin encoding can be added, with the formula acting as its own proxy symbol.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">preprocess_actions</span> <p>actions available during preprocessing.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-preprocess"><a href="#val-preprocess" class="anchor"></a><code><span><span class="keyword">val</span> preprocess : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Preprocess/index.html#type-t">Preprocess.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_preprocess"><a href="#val-on_preprocess" class="anchor"></a><code><span><span class="keyword">val</span> on_preprocess : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-preprocess_hook">preprocess_hook</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a hook that will be called when terms are preprocessed</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-preprocess_clause"><a href="#val-preprocess_clause" class="anchor"></a><code><span><span class="keyword">val</span> preprocess_clause : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sigs/index.html#type-step_id">Sigs.step_id</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> list</span> * <a href="../Sigs/index.html#type-step_id">Sigs.step_id</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-preprocess_clause_array"><a href="#val-preprocess_clause_array" class="anchor"></a><code><span><span class="keyword">val</span> preprocess_clause_array : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sigs/index.html#type-step_id">Sigs.step_id</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> array</span> * <a href="../Sigs/index.html#type-step_id">Sigs.step_id</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-simplify_and_preproc_lit"><a href="#val-simplify_and_preproc_lit" class="anchor"></a><code><span><span class="keyword">val</span> simplify_and_preproc_lit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Sigs/index.html#type-lit">Sigs.lit</a> * <span><a href="../Sigs/index.html#type-step_id">Sigs.step_id</a> option</span></span></code></div><div class="spec-doc"><p>Simplify literal then preprocess it</p></div></div><h4 id="finding-foreign-variables"><a href="#finding-foreign-variables" class="anchor"></a>Finding foreign variables</h4><div class="odoc-spec"><div class="spec value anchored" id="val-find_foreign"><a href="#val-find_foreign" class="anchor"></a><code><span><span class="keyword">val</span> find_foreign : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Find_foreign/index.html#type-t">Find_foreign.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_find_foreign"><a href="#val-on_find_foreign" class="anchor"></a><code><span><span class="keyword">val</span> on_find_foreign : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Find_foreign/index.html#type-hook">Find_foreign.hook</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a hook for finding foreign variables</p></div></div><h4 id="hooks-for-the-theory"><a href="#hooks-for-the-theory" class="anchor"></a>hooks for the theory</h4><div class="odoc-spec"><div class="spec value anchored" id="val-raise_conflict"><a href="#val-raise_conflict" class="anchor"></a><code><span><span class="keyword">val</span> raise_conflict : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-theory_actions">theory_actions</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Sidekick_proof/Pterm/index.html#type-delayed">Sidekick_proof.Pterm.delayed</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Give a conflict clause to the solver</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-push_decision"><a href="#val-push_decision" class="anchor"></a><code><span><span class="keyword">val</span> push_decision : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-theory_actions">theory_actions</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Ask the SAT solver to decide the given literal in an extension of the current trail. This is useful for theory combination. If the SAT solver backtracks, this (potential) decision is removed and forgotten.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-propagate"><a href="#val-propagate" class="anchor"></a><code><span><span class="keyword">val</span> propagate : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-theory_actions">theory_actions</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> <span class="arrow">&#45;&gt;</span></span>
  <span>reason:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> list</span> * <a href="../../Sidekick_proof/Pterm/index.html#type-delayed">Sidekick_proof.Pterm.delayed</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Propagate a boolean using a unit clause. <code>expl =&gt; lit</code> must be a theory lemma, that is, a T-tautology</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-propagate_l"><a href="#val-propagate_l" class="anchor"></a><code><span><span class="keyword">val</span> propagate_l : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-theory_actions">theory_actions</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Sidekick_proof/Pterm/index.html#type-delayed">Sidekick_proof.Pterm.delayed</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Propagate a boolean using a unit clause. <code>expl =&gt; lit</code> must be a theory lemma, that is, a T-tautology</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_clause_temp"><a href="#val-add_clause_temp" class="anchor"></a><code><span><span class="keyword">val</span> add_clause_temp : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-theory_actions">theory_actions</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Sidekick_proof/Pterm/index.html#type-delayed">Sidekick_proof.Pterm.delayed</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Add local clause to the SAT solver. This clause will be removed when the solver backtracks.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_clause_permanent"><a href="#val-add_clause_permanent" class="anchor"></a><code><span><span class="keyword">val</span> add_clause_permanent : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-theory_actions">theory_actions</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Sidekick_proof/Pterm/index.html#type-delayed">Sidekick_proof.Pterm.delayed</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Add toplevel clause to the SAT solver. This clause will not be backtracked.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_ty"><a href="#val-add_ty" class="anchor"></a><code><span><span class="keyword">val</span> add_ty : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>ty:<a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Declare a sort for the SMT solver</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk_lit"><a href="#val-mk_lit" class="anchor"></a><code><span><span class="keyword">val</span> mk_lit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>?sign:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Sigs/index.html#type-lit">Sigs.lit</a></span></code></div><div class="spec-doc"><p>Create a literal. This automatically preprocesses the term.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_lit"><a href="#val-add_lit" class="anchor"></a><code><span><span class="keyword">val</span> add_lit : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-theory_actions">theory_actions</a> <span class="arrow">&#45;&gt;</span></span> <span>?default_pol:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add the given literal to the SAT solver, so it gets assigned a boolean value.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">default_pol</span> <p>default polarity for the corresponding atom</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_lit_t"><a href="#val-add_lit_t" class="anchor"></a><code><span><span class="keyword">val</span> add_lit_t : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-theory_actions">theory_actions</a> <span class="arrow">&#45;&gt;</span></span> <span>?sign:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add the given (signed) bool term to the SAT solver, so it gets assigned a boolean value</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cc_find"><a href="#val-cc_find" class="anchor"></a><code><span><span class="keyword">val</span> cc_find : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Sidekick_cc/E_node/index.html#type-t">Sidekick_cc.E_node.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Sidekick_cc/E_node/index.html#type-t">Sidekick_cc.E_node.t</a></span></code></div><div class="spec-doc"><p>Find representative of the node</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cc_are_equal"><a href="#val-cc_are_equal" class="anchor"></a><code><span><span class="keyword">val</span> cc_are_equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Are these two terms equal in the congruence closure?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cc_resolve_expl"><a href="#val-cc_resolve_expl" class="anchor"></a><code><span><span class="keyword">val</span> cc_resolve_expl : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Sidekick_cc/Expl/index.html#type-t">Sidekick_cc.Expl.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> list</span> * <a href="../../Sidekick_proof/Pterm/index.html#type-delayed">Sidekick_proof.Pterm.delayed</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cc_add_term"><a href="#val-cc_add_term" class="anchor"></a><code><span><span class="keyword">val</span> cc_add_term : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Sidekick_cc/E_node/index.html#type-t">Sidekick_cc.E_node.t</a></span></code></div><div class="spec-doc"><p>Add/retrieve congruence closure node for this term. To be used in theories</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cc_mem_term"><a href="#val-cc_mem_term" class="anchor"></a><code><span><span class="keyword">val</span> cc_mem_term : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Return <code>true</code> if the term is explicitly in the congruence closure. To be used in theories</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_cc_pre_merge"><a href="#val-on_cc_pre_merge" class="anchor"></a><code><span><span class="keyword">val</span> on_cc_pre_merge : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<a href="../../Sidekick_cc/CC/index.html#type-t">Sidekick_cc.CC.t</a>
    * <a href="../../Sidekick_cc/E_node/index.html#type-t">Sidekick_cc.E_node.t</a>
    * <a href="../../Sidekick_cc/E_node/index.html#type-t">Sidekick_cc.E_node.t</a>
    * <a href="../../Sidekick_cc/Expl/index.html#type-t">Sidekick_cc.Expl.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
    <a href="../../Sidekick_cc/CC/Handler_action/index.html#type-or_conflict">Sidekick_cc.CC.Handler_action.or_conflict</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Callback for when two classes containing data for this key are merged (called before)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_cc_post_merge"><a href="#val-on_cc_post_merge" class="anchor"></a><code><span><span class="keyword">val</span> on_cc_post_merge : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<a href="../../Sidekick_cc/CC/index.html#type-t">Sidekick_cc.CC.t</a> * <a href="../../Sidekick_cc/E_node/index.html#type-t">Sidekick_cc.E_node.t</a> * <a href="../../Sidekick_cc/E_node/index.html#type-t">Sidekick_cc.E_node.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
    <span><a href="../../Sidekick_cc/CC/Handler_action/index.html#type-t">Sidekick_cc.CC.Handler_action.t</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Callback for when two classes containing data for this key are merged (called after)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_cc_new_term"><a href="#val-on_cc_new_term" class="anchor"></a><code><span><span class="keyword">val</span> on_cc_new_term : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<a href="../../Sidekick_cc/CC/index.html#type-t">Sidekick_cc.CC.t</a> * <a href="../../Sidekick_cc/E_node/index.html#type-t">Sidekick_cc.E_node.t</a> * <a href="../Sigs/index.html#type-term">Sigs.term</a>)</span> <span class="arrow">&#45;&gt;</span></span>
    <span><a href="../../Sidekick_cc/CC/Handler_action/index.html#type-t">Sidekick_cc.CC.Handler_action.t</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Callback to add data on terms when they are added to the congruence closure</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_cc_is_subterm"><a href="#val-on_cc_is_subterm" class="anchor"></a><code><span><span class="keyword">val</span> on_cc_is_subterm : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<a href="../../Sidekick_cc/CC/index.html#type-t">Sidekick_cc.CC.t</a> * <a href="../../Sidekick_cc/E_node/index.html#type-t">Sidekick_cc.E_node.t</a> * <a href="../Sigs/index.html#type-term">Sigs.term</a>)</span> <span class="arrow">&#45;&gt;</span></span>
    <span><a href="../../Sidekick_cc/CC/Handler_action/index.html#type-t">Sidekick_cc.CC.Handler_action.t</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Callback for when a term is a subterm of another term in the congruence closure</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_cc_conflict"><a href="#val-on_cc_conflict" class="anchor"></a><code><span><span class="keyword">val</span> on_cc_conflict : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../../Sidekick_cc/CC/index.html#type-ev_on_conflict">Sidekick_cc.CC.ev_on_conflict</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Callback called on every CC conflict</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_cc_propagate"><a href="#val-on_cc_propagate" class="anchor"></a><code><span><span class="keyword">val</span> on_cc_propagate : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<a href="../../Sidekick_cc/CC/index.html#type-t">Sidekick_cc.CC.t</a>
    * <a href="../Sigs/index.html#type-lit">Sigs.lit</a>
    * <span>(<span>unit <span class="arrow">&#45;&gt;</span></span>
    <span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> list</span> * <a href="../../Sidekick_proof/Pterm/index.html#type-delayed">Sidekick_proof.Pterm.delayed</a>)</span>)</span> <span class="arrow">&#45;&gt;</span></span>
    <span><a href="../../Sidekick_cc/CC/Handler_action/index.html#type-t">Sidekick_cc.CC.Handler_action.t</a> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Callback called on every CC propagation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_new_ty"><a href="#val-on_new_ty" class="anchor"></a><code><span><span class="keyword">val</span> on_new_ty : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../Sigs/index.html#type-ty">Sigs.ty</a>, unit)</span> <a href="../../Sidekick_util/Event/index.html#type-t">Sidekick_util.Event.t</a></span></span></code></div><div class="spec-doc"><p>Add a callback for when new types are added via <a href="#val-add_ty"><code>add_ty</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_partial_check"><a href="#val-on_partial_check" class="anchor"></a><code><span><span class="keyword">val</span> on_partial_check : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-theory_actions">theory_actions</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> <span class="xref-unresolved">Iter</span>.t</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Register callbacked to be called with the slice of literals newly added on the trail.</p><p>This is called very often and should be efficient. It doesn't have to be complete, only correct. It's given only the slice of the trail consisting in new literals.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_final_check"><a href="#val-on_final_check" class="anchor"></a><code><span><span class="keyword">val</span> on_final_check : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-theory_actions">theory_actions</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Sigs/index.html#type-lit">Sigs.lit</a> <span class="xref-unresolved">Iter</span>.t</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Register callback to be called during the final check.</p><p>Must be complete (i.e. must raise a conflict if the set of literals is not satisfiable) and can be expensive. The function is given the whole trail.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-declare_pb_is_incomplete"><a href="#val-declare_pb_is_incomplete" class="anchor"></a><code><span><span class="keyword">val</span> declare_pb_is_incomplete : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Declare that, in some theory, the problem is outside the logic fragment that is decidable (e.g. if we meet proper NIA formulas). The solver will not reply &quot;SAT&quot; from now on.</p></div></div><h4 id="model-production"><a href="#model-production" class="anchor"></a>Model production</h4><div class="odoc-spec"><div class="spec type anchored" id="type-model_ask_hook"><a href="#type-model_ask_hook" class="anchor"></a><code><span><span class="keyword">type</span> model_ask_hook</span><span> =
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Model_builder/index.html#type-t">Model_builder.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Sidekick_core/Term/index.html#type-t">Sidekick_core.Term.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Sigs/index.html#type-value">Sigs.value</a> * <span><a href="../../Sidekick_core/Term/index.html#type-t">Sidekick_core.Term.t</a> list</span>)</span> option</span></span></code></div><div class="spec-doc"><p>A model-production hook to query values from a theory.</p><p>It takes the solver, a class, and returns an optional value for this class (potentially with sub-terms to find values for, if the value is actually a skeleton).</p><p>For example, an arithmetic theory might detect that a class contains a numeric constant, and return this constant as a model value. The theory of arrays might return <code>array.const $v</code> for an array <code>Array A B</code>, where <code>$v</code> will be picked by the theory of the sort <code>B</code>.</p><p>If no hook assigns a value to a class, a fake value is created for it.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-model_completion_hook"><a href="#type-model_completion_hook" class="anchor"></a><code><span><span class="keyword">type</span> model_completion_hook</span><span> = <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>add:<span>(<span><a href="../Sigs/index.html#type-term">Sigs.term</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Sigs/index.html#type-value">Sigs.value</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>A model production hook, for the theory to add values. The hook is given a <code>add</code> function to add bindings to the model.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_model"><a href="#val-on_model" class="anchor"></a><code><span><span class="keyword">val</span> on_model : 
  <span>?ask:<a href="#type-model_ask_hook">model_ask_hook</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?complete:<a href="#type-model_completion_hook">model_completion_hook</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Add model production/completion hooks.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_progress"><a href="#val-on_progress" class="anchor"></a><code><span><span class="keyword">val</span> on_progress : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, unit)</span> <a href="../../Sidekick_util/Event/index.html#type-t">Sidekick_util.Event.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_complete"><a href="#val-is_complete" class="anchor"></a><code><span><span class="keyword">val</span> is_complete : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Are we still in a complete logic fragment?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-last_model"><a href="#val-last_model" class="anchor"></a><code><span><span class="keyword">val</span> last_model : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Model/index.html#type-t">Model.t</a> option</span></span></code></div></div><h3 id="delayed-actions"><a href="#delayed-actions" class="anchor"></a>Delayed actions</h3><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-PERFORM_ACTS"><a href="#module-type-PERFORM_ACTS" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PERFORM_ACTS/index.html">PERFORM_ACTS</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Perform_delayed"><a href="#module-Perform_delayed" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Perform_delayed/index.html">Perform_delayed</a></span><span> (<a href="Perform_delayed/argument-1-A/index.html">A</a> : <a href="module-type-PERFORM_ACTS/index.html">PERFORM_ACTS</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_theory_state"><a href="#val-add_theory_state" class="anchor"></a><code><span><span class="keyword">val</span> add_theory_state : 
  <span>st:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span>push_level:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>pop_levels:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span><span>(<span class="keyword">module</span> <a href="../Sigs/module-type-ARG/index.html">Sigs.ARG</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>stat:<a href="../../Sidekick_util/Stat/index.html#type-t">Sidekick_util.Stat.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>tracer:<a href="../Tracer/class-type-t/index.html">Tracer.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Sidekick_core/Term/index.html#type-store">Sidekick_core.Term.store</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div></div></div></body></html>