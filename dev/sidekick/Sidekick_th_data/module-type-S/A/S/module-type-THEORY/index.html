<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>THEORY (sidekick.Sidekick_th_data.S.A.S.THEORY)</title><link rel="stylesheet" href="../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../index.html">sidekick</a> &#x00BB; <a href="../../../../index.html">Sidekick_th_data</a> &#x00BB; <a href="../../../index.html">S</a> &#x00BB; <a href="../../index.html">A</a> &#x00BB; <a href="../index.html">S</a> &#x00BB; THEORY</nav><header class="odoc-preamble"><h1>Module type <code><span>S.THEORY</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#a-theory">A theory</a></li></ul></nav><div class="odoc-content"><h4 id="a-theory"><a href="#a-theory" class="anchor"></a>A theory</h4><p>Theories are abstracted over the concrete implementation of the solver, so they can work with any implementation.</p><p>Typically a theory should be a functor taking an argument containing a <code>SOLVER_INTERNAL</code> or even a full <code>SOLVER</code>, and some additional views on terms, literals, etc. that are specific to the theory (e.g. to map terms to linear expressions). The theory can then be instantiated on any kind of solver for any term representation that also satisfies the additional theory-specific requirements. Instantiated theories (ie values of type <code>SOLVER</code>.theory) can be added to the solver.</p><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The theory's state</p></div></div><div class="odoc-spec"><div class="spec value" id="val-name" class="anchored"><a href="#val-name" class="anchor"></a><code><span><span class="keyword">val</span> name : string</span></code></div><div class="spec-doc"><p>Name of the theory (ideally, unique and short)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_and_setup" class="anchored"><a href="#val-create_and_setup" class="anchor"></a><code><span><span class="keyword">val</span> create_and_setup : <span><a href="../Solver_internal/index.html#type-t">Solver_internal.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Instantiate the theory's state for the given (internal) solver, register callbacks, create keys, etc.</p><p>Called once for every solver this theory is added to.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-push_level" class="anchored"><a href="#val-push_level" class="anchor"></a><code><span><span class="keyword">val</span> push_level : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Push backtracking level. When the corresponding pop is called, the theory's state should be restored to a state <b>equivalent</b> to what it was just before <code>push_level</code>.</p><p>it does not have to be exactly the same state, it just needs to be equivalent.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pop_levels" class="anchored"><a href="#val-pop_levels" class="anchor"></a><code><span><span class="keyword">val</span> pop_levels : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pop_levels theory n</code> pops <code>n</code> backtracking levels, restoring <code>theory</code> to its state before calling <code>push_level</code> n times.</p></div></div></div></body></html>